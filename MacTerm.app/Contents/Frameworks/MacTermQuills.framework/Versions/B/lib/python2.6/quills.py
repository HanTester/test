# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
The `Quills` module exposes the entire MacTerm API to Python,
allowing you to directly access core functionality from scripts!
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_quills', [dirname(__file__)])
        except ImportError:
            import _quills
            return _quills
        if fp is not None:
            try:
                _mod = imp.load_module('_quills', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _quills = swig_import_helper()
    del swig_import_helper
else:
    import _quills
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _quills.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _quills.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _quills.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _quills.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _quills.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _quills.SwigPyIterator_equal(self, x)

    def copy(self):
        return _quills.SwigPyIterator_copy(self)

    def next(self):
        return _quills.SwigPyIterator_next(self)

    def __next__(self):
        return _quills.SwigPyIterator___next__(self)

    def previous(self):
        return _quills.SwigPyIterator_previous(self)

    def advance(self, n):
        return _quills.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _quills.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _quills.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _quills.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _quills.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _quills.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _quills.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _quills.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class _float_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _float_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _float_list, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _quills._float_list_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _quills._float_list___nonzero__(self)

    def __bool__(self):
        return _quills._float_list___bool__(self)

    def __len__(self):
        return _quills._float_list___len__(self)

    def pop(self):
        return _quills._float_list_pop(self)

    def __getslice__(self, i, j):
        return _quills._float_list___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _quills._float_list___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _quills._float_list___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _quills._float_list___delitem__(self, *args)

    def __getitem__(self, *args):
        return _quills._float_list___getitem__(self, *args)

    def __setitem__(self, *args):
        return _quills._float_list___setitem__(self, *args)

    def append(self, x):
        return _quills._float_list_append(self, x)

    def empty(self):
        return _quills._float_list_empty(self)

    def size(self):
        return _quills._float_list_size(self)

    def clear(self):
        return _quills._float_list_clear(self)

    def swap(self, v):
        return _quills._float_list_swap(self, v)

    def get_allocator(self):
        return _quills._float_list_get_allocator(self)

    def begin(self):
        return _quills._float_list_begin(self)

    def end(self):
        return _quills._float_list_end(self)

    def rbegin(self):
        return _quills._float_list_rbegin(self)

    def rend(self):
        return _quills._float_list_rend(self)

    def pop_back(self):
        return _quills._float_list_pop_back(self)

    def erase(self, *args):
        return _quills._float_list_erase(self, *args)

    def __init__(self, *args):
        this = _quills.new__float_list(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _quills._float_list_push_back(self, x)

    def front(self):
        return _quills._float_list_front(self)

    def back(self):
        return _quills._float_list_back(self)

    def assign(self, n, x):
        return _quills._float_list_assign(self, n, x)

    def resize(self, *args):
        return _quills._float_list_resize(self, *args)

    def insert(self, *args):
        return _quills._float_list_insert(self, *args)

    def reserve(self, n):
        return _quills._float_list_reserve(self, n)

    def capacity(self):
        return _quills._float_list_capacity(self)
    __swig_destroy__ = _quills.delete__float_list
    __del__ = lambda self: None
_float_list_swigregister = _quills._float_list_swigregister
_float_list_swigregister(_float_list)

class _long_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _long_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _long_list, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _quills._long_list_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _quills._long_list___nonzero__(self)

    def __bool__(self):
        return _quills._long_list___bool__(self)

    def __len__(self):
        return _quills._long_list___len__(self)

    def pop(self):
        return _quills._long_list_pop(self)

    def __getslice__(self, i, j):
        return _quills._long_list___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _quills._long_list___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _quills._long_list___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _quills._long_list___delitem__(self, *args)

    def __getitem__(self, *args):
        return _quills._long_list___getitem__(self, *args)

    def __setitem__(self, *args):
        return _quills._long_list___setitem__(self, *args)

    def append(self, x):
        return _quills._long_list_append(self, x)

    def empty(self):
        return _quills._long_list_empty(self)

    def size(self):
        return _quills._long_list_size(self)

    def clear(self):
        return _quills._long_list_clear(self)

    def swap(self, v):
        return _quills._long_list_swap(self, v)

    def get_allocator(self):
        return _quills._long_list_get_allocator(self)

    def begin(self):
        return _quills._long_list_begin(self)

    def end(self):
        return _quills._long_list_end(self)

    def rbegin(self):
        return _quills._long_list_rbegin(self)

    def rend(self):
        return _quills._long_list_rend(self)

    def pop_back(self):
        return _quills._long_list_pop_back(self)

    def erase(self, *args):
        return _quills._long_list_erase(self, *args)

    def __init__(self, *args):
        this = _quills.new__long_list(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _quills._long_list_push_back(self, x)

    def front(self):
        return _quills._long_list_front(self)

    def back(self):
        return _quills._long_list_back(self)

    def assign(self, n, x):
        return _quills._long_list_assign(self, n, x)

    def resize(self, *args):
        return _quills._long_list_resize(self, *args)

    def insert(self, *args):
        return _quills._long_list_insert(self, *args)

    def reserve(self, n):
        return _quills._long_list_reserve(self, n)

    def capacity(self):
        return _quills._long_list_capacity(self)
    __swig_destroy__ = _quills.delete__long_list
    __del__ = lambda self: None
_long_list_swigregister = _quills._long_list_swigregister
_long_list_swigregister(_long_list)

class _long_pair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _long_pair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _long_pair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _quills.new__long_pair(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_setmethods__["first"] = _quills._long_pair_first_set
    __swig_getmethods__["first"] = _quills._long_pair_first_get
    if _newclass:
        first = _swig_property(_quills._long_pair_first_get, _quills._long_pair_first_set)
    __swig_setmethods__["second"] = _quills._long_pair_second_set
    __swig_getmethods__["second"] = _quills._long_pair_second_get
    if _newclass:
        second = _swig_property(_quills._long_pair_second_get, _quills._long_pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _quills.delete__long_pair
    __del__ = lambda self: None
_long_pair_swigregister = _quills._long_pair_swigregister
_long_pair_swigregister(_long_pair)

class _string_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _string_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _string_list, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _quills._string_list_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _quills._string_list___nonzero__(self)

    def __bool__(self):
        return _quills._string_list___bool__(self)

    def __len__(self):
        return _quills._string_list___len__(self)

    def pop(self):
        return _quills._string_list_pop(self)

    def __getslice__(self, i, j):
        return _quills._string_list___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _quills._string_list___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _quills._string_list___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _quills._string_list___delitem__(self, *args)

    def __getitem__(self, *args):
        return _quills._string_list___getitem__(self, *args)

    def __setitem__(self, *args):
        return _quills._string_list___setitem__(self, *args)

    def append(self, x):
        return _quills._string_list_append(self, x)

    def empty(self):
        return _quills._string_list_empty(self)

    def size(self):
        return _quills._string_list_size(self)

    def clear(self):
        return _quills._string_list_clear(self)

    def swap(self, v):
        return _quills._string_list_swap(self, v)

    def get_allocator(self):
        return _quills._string_list_get_allocator(self)

    def begin(self):
        return _quills._string_list_begin(self)

    def end(self):
        return _quills._string_list_end(self)

    def rbegin(self):
        return _quills._string_list_rbegin(self)

    def rend(self):
        return _quills._string_list_rend(self)

    def pop_back(self):
        return _quills._string_list_pop_back(self)

    def erase(self, *args):
        return _quills._string_list_erase(self, *args)

    def __init__(self, *args):
        this = _quills.new__string_list(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _quills._string_list_push_back(self, x)

    def front(self):
        return _quills._string_list_front(self)

    def back(self):
        return _quills._string_list_back(self)

    def assign(self, n, x):
        return _quills._string_list_assign(self, n, x)

    def resize(self, *args):
        return _quills._string_list_resize(self, *args)

    def insert(self, *args):
        return _quills._string_list_insert(self, *args)

    def reserve(self, n):
        return _quills._string_list_reserve(self, n)

    def capacity(self):
        return _quills._string_list_capacity(self)
    __swig_destroy__ = _quills.delete__string_list
    __del__ = lambda self: None
_string_list_swigregister = _quills._string_list_swigregister
_string_list_swigregister(_string_list)

class _string_by_long(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _string_by_long, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _string_by_long, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _quills._string_by_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _quills._string_by_long___nonzero__(self)

    def __bool__(self):
        return _quills._string_by_long___bool__(self)

    def __len__(self):
        return _quills._string_by_long___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _quills._string_by_long___getitem__(self, key)

    def __delitem__(self, key):
        return _quills._string_by_long___delitem__(self, key)

    def has_key(self, key):
        return _quills._string_by_long_has_key(self, key)

    def keys(self):
        return _quills._string_by_long_keys(self)

    def values(self):
        return _quills._string_by_long_values(self)

    def items(self):
        return _quills._string_by_long_items(self)

    def __contains__(self, key):
        return _quills._string_by_long___contains__(self, key)

    def key_iterator(self):
        return _quills._string_by_long_key_iterator(self)

    def value_iterator(self):
        return _quills._string_by_long_value_iterator(self)

    def __setitem__(self, *args):
        return _quills._string_by_long___setitem__(self, *args)

    def asdict(self):
        return _quills._string_by_long_asdict(self)

    def __init__(self, *args):
        this = _quills.new__string_by_long(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _quills._string_by_long_empty(self)

    def size(self):
        return _quills._string_by_long_size(self)

    def clear(self):
        return _quills._string_by_long_clear(self)

    def swap(self, v):
        return _quills._string_by_long_swap(self, v)

    def get_allocator(self):
        return _quills._string_by_long_get_allocator(self)

    def begin(self):
        return _quills._string_by_long_begin(self)

    def end(self):
        return _quills._string_by_long_end(self)

    def rbegin(self):
        return _quills._string_by_long_rbegin(self)

    def rend(self):
        return _quills._string_by_long_rend(self)

    def count(self, x):
        return _quills._string_by_long_count(self, x)

    def erase(self, *args):
        return _quills._string_by_long_erase(self, *args)

    def find(self, x):
        return _quills._string_by_long_find(self, x)

    def lower_bound(self, x):
        return _quills._string_by_long_lower_bound(self, x)

    def upper_bound(self, x):
        return _quills._string_by_long_upper_bound(self, x)
    __swig_destroy__ = _quills.delete__string_by_long
    __del__ = lambda self: None
_string_by_long_swigregister = _quills._string_by_long_swigregister
_string_by_long_swigregister(_string_by_long)

class Base(_object):
    """
    Core APIs for setup and teardown of Quills, and a version API.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def all_init(*args, **kwargs):
        """
        all_init(initial_workspace)

        Initialize every module, in dependency order.  May also trigger
        side effects such as launching initial windows.

        The parameter is optional; if set, it should be the name of a
        valid Prefs.WORKSPACE context to use as the source of windows
        spawned at startup time.  The purpose of this is to allow some
        intelligence in your environment; for instance, you might check if
        your computer is connected to a VPN (based on its host name), and
        choose different default windows based on the servers that are
        currently visible to your computer.

        """
        return _quills.Base_all_init(*args, **kwargs)

    if _newclass:
        all_init = staticmethod(all_init)
    __swig_getmethods__["all_init"] = lambda x: all_init

    def all_done(*args):
        """
        all_done()

        Tear down every module, in reverse dependency order.  Generally
        cripples Quills APIs, since their implementation modules will no
        longer be initialized.  (The exception is any that initialize
        just-in-time.)

        """
        return _quills.Base_all_done(*args)

    if _newclass:
        all_done = staticmethod(all_done)
    __swig_getmethods__["all_done"] = lambda x: all_done

    def version(*args):
        """
        version() -> std::string

        Return the CFBundleVersion field from the Info.plist of the
        main bundle.

        The string encoding is UTF-8.

        """
        return _quills.Base_version(*args)

    if _newclass:
        version = staticmethod(version)
    __swig_getmethods__["version"] = lambda x: version

    def _initial_workspace_name(*args):
        """_initial_workspace_name() -> std::string"""
        return _quills.Base__initial_workspace_name(*args)

    if _newclass:
        _initial_workspace_name = staticmethod(_initial_workspace_name)
    __swig_getmethods__["_initial_workspace_name"] = lambda x: _initial_workspace_name

    def _version_warning(*args):
        """_version_warning()"""
        return _quills.Base__version_warning(*args)

    if _newclass:
        _version_warning = staticmethod(_version_warning)
    __swig_getmethods__["_version_warning"] = lambda x: _version_warning
    __swig_destroy__ = _quills.delete_Base
    __del__ = lambda self: None
Base_swigregister = _quills.Base_swigregister
Base_swigregister(Base)

def Base_all_init(*args, **kwargs):
    """
    Base_all_init(initial_workspace)

    Initialize every module, in dependency order.  May also trigger
    side effects such as launching initial windows.

    The parameter is optional; if set, it should be the name of a
    valid Prefs.WORKSPACE context to use as the source of windows
    spawned at startup time.  The purpose of this is to allow some
    intelligence in your environment; for instance, you might check if
    your computer is connected to a VPN (based on its host name), and
    choose different default windows based on the servers that are
    currently visible to your computer.

    """
    return _quills.Base_all_init(*args, **kwargs)

def Base_all_done(*args):
    """
    Base_all_done()

    Tear down every module, in reverse dependency order.  Generally
    cripples Quills APIs, since their implementation modules will no
    longer be initialized.  (The exception is any that initialize
    just-in-time.)

    """
    return _quills.Base_all_done(*args)

def Base_version(*args):
    """
    Base_version() -> std::string

    Return the CFBundleVersion field from the Info.plist of the
    main bundle.

    The string encoding is UTF-8.

    """
    return _quills.Base_version(*args)

def Base__initial_workspace_name(*args):
    """Base__initial_workspace_name() -> std::string"""
    return _quills.Base__initial_workspace_name(*args)

def Base__version_warning(*args):
    """Base__version_warning()"""
    return _quills.Base__version_warning(*args)

class Events(_object):
    """
    Manage setup and teardown of the main application event loop.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Events, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Events, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def run_loop(*args):
        """
        run_loop()

        Begin graphical user interface interaction.  Complete control
        is given to the user, any future callbacks to the code are made
        in response to actions such as clicks on menus and buttons.

        IMPORTANT: This call blocks until the user asks to quit.

        """
        return _quills.Events_run_loop(*args)

    if _newclass:
        run_loop = staticmethod(run_loop)
    __swig_getmethods__["run_loop"] = lambda x: run_loop

    def _handle_endloop(*args):
        """_handle_endloop()"""
        return _quills.Events__handle_endloop(*args)

    if _newclass:
        _handle_endloop = staticmethod(_handle_endloop)
    __swig_getmethods__["_handle_endloop"] = lambda x: _handle_endloop

    def _on_endloop_call_py(*args):
        """_on_endloop_call_py(arg1, arg2)"""
        return _quills.Events__on_endloop_call_py(*args)

    if _newclass:
        _on_endloop_call_py = staticmethod(_on_endloop_call_py)
    __swig_getmethods__["_on_endloop_call_py"] = lambda x: _on_endloop_call_py

    def on_endloop_call(*args):
        """
        on_endloop_call(inPythonFunction)

        Register a Python function to be called (with no arguments)
        immediately after the main event loop terminates.

        This is the only way for Python code to continue running after
        you call Events.run_loop().  At some point in this callback,
        you MUST call Base.all_done() to clean up application modules.

        """
        return _quills.Events_on_endloop_call(*args)

    if _newclass:
        on_endloop_call = staticmethod(on_endloop_call)
    __swig_getmethods__["on_endloop_call"] = lambda x: on_endloop_call
    __swig_destroy__ = _quills.delete_Events
    __del__ = lambda self: None
Events_swigregister = _quills.Events_swigregister
Events_swigregister(Events)

def Events_run_loop(*args):
    """
    Events_run_loop()

    Begin graphical user interface interaction.  Complete control
    is given to the user, any future callbacks to the code are made
    in response to actions such as clicks on menus and buttons.

    IMPORTANT: This call blocks until the user asks to quit.

    """
    return _quills.Events_run_loop(*args)

def Events__handle_endloop(*args):
    """Events__handle_endloop()"""
    return _quills.Events__handle_endloop(*args)

def Events__on_endloop_call_py(*args):
    """Events__on_endloop_call_py(arg2, arg3)"""
    return _quills.Events__on_endloop_call_py(*args)

def Events_on_endloop_call(*args):
    """
    Events_on_endloop_call(inPythonFunction)

    Register a Python function to be called (with no arguments)
    immediately after the main event loop terminates.

    This is the only way for Python code to continue running after
    you call Events.run_loop().  At some point in this callback,
    you MUST call Base.all_done() to clean up application modules.

    """
    return _quills.Events_on_endloop_call(*args)

class Prefs(_object):
    """
    Access and modify user preferences.

    Preferences are grouped in the following classes:
    - GENERAL -- Preferences not typically found in collections.
    - FORMAT -- Font and color settings.
    - MACRO_SET -- Actions mapped to keyboard short-cuts.
    - SESSION -- How to reach, and interact with, a resource.
    - TERMINAL -- Characteristics of the emulator and its data storage.
    - TRANSLATION -- Text encoding.
    - WORKSPACE -- Windows that are spawned at the same time.
    - _FACTORY_DEFAULTS -- Represents the DefaultPreferences.plist,
      for internal use only.
    - _RESTORE_AT_LAUNCH -- Represents settings that are saved
      automatically and restored when requested by the user;
      transient and for internal use only.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Prefs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Prefs, name)
    __repr__ = _swig_repr
    GENERAL = _quills.Prefs_GENERAL
    FORMAT = _quills.Prefs_FORMAT
    MACRO_SET = _quills.Prefs_MACRO_SET
    SESSION = _quills.Prefs_SESSION
    TERMINAL = _quills.Prefs_TERMINAL
    TRANSLATION = _quills.Prefs_TRANSLATION
    WORKSPACE = _quills.Prefs_WORKSPACE
    _FACTORY_DEFAULTS = _quills.Prefs__FACTORY_DEFAULTS
    _RESTORE_AT_LAUNCH = _quills.Prefs__RESTORE_AT_LAUNCH

    def __init__(self, *args):
        """
        __init__(self, inClass) -> Prefs

        Create a new collection of the given type.

        Currently, only in-memory (temporary) collections are supported
        through this interface.

        """
        this = _quills.new_Prefs(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _quills.delete_Prefs
    __del__ = lambda self: None

    def define_macro(self, *args, **kwargs):
        """
        define_macro(self, index_in_set, name, contents)

        Add or modify a macro in this collection.

        The index is at least 1, and specifies which macro in the set
        to change.

        The keyword arguments are optional; any that are given will be
        assigned as attributes of the macro.  Currently, not all
        possible attributes can be set from scripts.

        Any given strings must use UTF-8 encoding.

        """
        return _quills.Prefs_define_macro(self, *args, **kwargs)


    def import_from_file(*args, **kwargs):
        """
        import_from_file(pathname, allow_rename=True)

        Create a new collection containing the settings from the given
        file.  The class will be based on the majority of the settings.

        If the file contains an embedded name key such as "name-string"
        and the name does not conflict with any other collection in the
        chosen category then the collection is given that name.  If the
        name does conflict, the normal behavior is to raise an exception;
        but "allow_rename" can be set to force a unique name in this
        situation.

        """
        return _quills.Prefs_import_from_file(*args, **kwargs)

    if _newclass:
        import_from_file = staticmethod(import_from_file)
    __swig_getmethods__["import_from_file"] = lambda x: import_from_file

    def list_collections(*args):
        """
        list_collections(of_class) -> _string_list

        Return a list of collection names for preferences saved in the
        given category, if any.

        Each string is in UTF-8 encoding.

        """
        return _quills.Prefs_list_collections(*args)

    if _newclass:
        list_collections = staticmethod(list_collections)
    __swig_getmethods__["list_collections"] = lambda x: list_collections

    def _set_current_macros(*args):
        """_set_current_macros(arg1)"""
        return _quills.Prefs__set_current_macros(*args)

    if _newclass:
        _set_current_macros = staticmethod(_set_current_macros)
    __swig_getmethods__["_set_current_macros"] = lambda x: _set_current_macros

    def set_current_macros(*args):
        """
        set_current_macros(new_set)

        Change the active macro set to the specified collection,
        which should be a Prefs instance of type MACRO_SET.

        Since changes to collections are detected, you may continue to
        modify the specified macros, and anything that depends on them
        (such as a Macros menu) will update automatically.

        """
        return _quills.Prefs_set_current_macros(*args)

    if _newclass:
        set_current_macros = staticmethod(set_current_macros)
    __swig_getmethods__["set_current_macros"] = lambda x: set_current_macros
Prefs_swigregister = _quills.Prefs_swigregister
Prefs_swigregister(Prefs)

def Prefs_import_from_file(*args, **kwargs):
    """
    Prefs_import_from_file(pathname, allow_rename=True)

    Create a new collection containing the settings from the given
    file.  The class will be based on the majority of the settings.

    If the file contains an embedded name key such as "name-string"
    and the name does not conflict with any other collection in the
    chosen category then the collection is given that name.  If the
    name does conflict, the normal behavior is to raise an exception;
    but "allow_rename" can be set to force a unique name in this
    situation.

    """
    return _quills.Prefs_import_from_file(*args, **kwargs)

def Prefs_list_collections(*args):
    """
    Prefs_list_collections(of_class) -> _string_list

    Return a list of collection names for preferences saved in the
    given category, if any.

    Each string is in UTF-8 encoding.

    """
    return _quills.Prefs_list_collections(*args)

def Prefs__set_current_macros(*args):
    """Prefs__set_current_macros(arg2)"""
    return _quills.Prefs__set_current_macros(*args)

def Prefs_set_current_macros(*args):
    """
    Prefs_set_current_macros(new_set)

    Change the active macro set to the specified collection,
    which should be a Prefs instance of type MACRO_SET.

    Since changes to collections are detected, you may continue to
    modify the specified macros, and anything that depends on them
    (such as a Macros menu) will update automatically.

    """
    return _quills.Prefs_set_current_macros(*args)

class Session(_object):
    """
    Run commands in terminal windows, and other Session-related actions.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Session, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Session, name)
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """
        __init__(self, argv, cwd) -> Session

        Create a new session with a terminal window, change to a
        specific directory (if 'cwd' is not empty) and run a Unix
        command line.  The session remains active until it is
        terminated by the user or the command finishes.

        """
        this = _quills.new_Session(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    def pseudo_terminal_device_name(self, *args):
        """
        pseudo_terminal_device_name(self) -> std::string

        Return the path of the pseudo-terminal device connected to the
        session; for example, '/dev/ttyp0'.  Writes to this device are
        immediately interpreted by the local terminal of the session!

        The character encoding is UTF-8.

        """
        return _quills.Session_pseudo_terminal_device_name(self, *args)


    def resource_location_string(self, *args):
        """
        resource_location_string(self) -> std::string

        Return a string describing the resource for the session, which
        will usually be its Unix command line.

        The character encoding is UTF-8.

        """
        return _quills.Session_resource_location_string(self, *args)


    def state_string(self, *args):
        """
        state_string(self) -> std::string

        Return a simple string description of the current state of the
        session.  For example, a session might be 'Running'.

        The character encoding is UTF-8.

        """
        return _quills.Session_state_string(self, *args)


    def handle_file(*args):
        """
        handle_file(pathname)

        Either invoke a Python callback to handle the specified file,
        or trigger the default MacTerm handler if no Python callback
        is available.  Callbacks registered via on_fileopen_call() are
        considered.

        Currently, file type is determined only using the extension of
        the pathname.

        This function returns nothing and is asynchronous; you can,
        however, use a routine like on_new_call() to be notified of
        new sessions when they appear.

        """
        return _quills.Session_handle_file(*args)

    if _newclass:
        handle_file = staticmethod(handle_file)
    __swig_getmethods__["handle_file"] = lambda x: handle_file

    def handle_url(*args):
        """
        handle_url(url)

        Either invoke a Python callback to handle the specified URL,
        or trigger the default MacTerm handler if no Python callback
        is available.  Callbacks registered via on_urlopen_call() are
        considered.

        This function returns nothing and is asynchronous; you can,
        however, use a routine like on_new_call() to be notified of
        new sessions when they appear.

        """
        return _quills.Session_handle_url(*args)

    if _newclass:
        handle_url = staticmethod(handle_url)
    __swig_getmethods__["handle_url"] = lambda x: handle_url

    def keep_alive_transmission(*args):
        """
        keep_alive_transmission() -> std::string

        Return what set_keep_alive_transmission() sets.

        """
        return _quills.Session_keep_alive_transmission(*args)

    if _newclass:
        keep_alive_transmission = staticmethod(keep_alive_transmission)
    __swig_getmethods__["keep_alive_transmission"] = lambda x: keep_alive_transmission

    def pids_cwds(*args):
        """
        pids_cwds(pids) -> _string_by_long

        Determine the current working directories of the specified
        processes, among user-owned processes.  The result is a map by
        process ID, where nonexistent entries could not be determined
        (because a process no longer exists or you lack permission,
        etc.).  Each process ID maps to a directory path string.

        The character encoding of directory path strings is UTF-8.

        """
        return _quills.Session_pids_cwds(*args)

    if _newclass:
        pids_cwds = staticmethod(pids_cwds)
    __swig_getmethods__["pids_cwds"] = lambda x: pids_cwds

    def set_keep_alive_transmission(*args):
        """
        set_keep_alive_transmission(text)

        Specify the text to send to the server when a long idle timer
        expires on a session that is watching for inactivity.

        Probably, this should be a very short string that will not
        interface with whatever happens to be running on the server; a
        single space is typical.

        """
        return _quills.Session_set_keep_alive_transmission(*args)

    if _newclass:
        set_keep_alive_transmission = staticmethod(set_keep_alive_transmission)
    __swig_getmethods__["set_keep_alive_transmission"] = lambda x: set_keep_alive_transmission

    def _on_fileopen_ext_call_py(*args):
        """_on_fileopen_ext_call_py(arg1, arg2, arg3)"""
        return _quills.Session__on_fileopen_ext_call_py(*args)

    if _newclass:
        _on_fileopen_ext_call_py = staticmethod(_on_fileopen_ext_call_py)
    __swig_getmethods__["_on_fileopen_ext_call_py"] = lambda x: _on_fileopen_ext_call_py

    def _on_new_call_py(*args):
        """_on_new_call_py(arg1, arg2)"""
        return _quills.Session__on_new_call_py(*args)

    if _newclass:
        _on_new_call_py = staticmethod(_on_new_call_py)
    __swig_getmethods__["_on_new_call_py"] = lambda x: _on_new_call_py

    def _on_seekpidscwds_call_py(*args):
        """_on_seekpidscwds_call_py(arg1, arg2)"""
        return _quills.Session__on_seekpidscwds_call_py(*args)

    if _newclass:
        _on_seekpidscwds_call_py = staticmethod(_on_seekpidscwds_call_py)
    __swig_getmethods__["_on_seekpidscwds_call_py"] = lambda x: _on_seekpidscwds_call_py

    def _on_urlopen_call_py(*args):
        """_on_urlopen_call_py(arg1, arg2, arg3)"""
        return _quills.Session__on_urlopen_call_py(*args)

    if _newclass:
        _on_urlopen_call_py = staticmethod(_on_urlopen_call_py)
    __swig_getmethods__["_on_urlopen_call_py"] = lambda x: _on_urlopen_call_py

    def _stop_fileopen_ext_call_py(*args):
        """_stop_fileopen_ext_call_py(arg1, arg2)"""
        return _quills.Session__stop_fileopen_ext_call_py(*args)

    if _newclass:
        _stop_fileopen_ext_call_py = staticmethod(_stop_fileopen_ext_call_py)
    __swig_getmethods__["_stop_fileopen_ext_call_py"] = lambda x: _stop_fileopen_ext_call_py

    def _stop_new_call_py(*args):
        """_stop_new_call_py(arg1)"""
        return _quills.Session__stop_new_call_py(*args)

    if _newclass:
        _stop_new_call_py = staticmethod(_stop_new_call_py)
    __swig_getmethods__["_stop_new_call_py"] = lambda x: _stop_new_call_py

    def _stop_urlopen_call_py(*args):
        """_stop_urlopen_call_py(arg1, arg2)"""
        return _quills.Session__stop_urlopen_call_py(*args)

    if _newclass:
        _stop_urlopen_call_py = staticmethod(_stop_urlopen_call_py)
    __swig_getmethods__["_stop_urlopen_call_py"] = lambda x: _stop_urlopen_call_py

    def on_fileopen_call(*args, **kwargs):
        """
        on_fileopen_call(inPythonFunction, extension)

        Register a Python function to be called, with a single string
        argument, every time an open is requested for a file with the
        given attribute.

        Specify only one attribute (keyword parameter) at a time.  You
        can reuse the same callback function, just register it more than
        once and provide a different attribute for each call.

        Currently, the only supported attribute is 'extension', which
        refers to the end of the filename without a dot (.).  Examples
        include 'txt' for text, and 'sh' for Bourne shell.  Note that the
        Finder obeys extension mappings in the 'Info.plist' file of the
        application bundle, so you may wish to update that file when
        adding new handlers.  If the 'Info.plist' does not include the
        extension you choose, your handler will only be used for files
        that are forced to open with MacTerm (say, when they are dragged
        onto the Dock icon).

        You cannot register more than one Python function for the same
        attribute.  Registering a Python function for an attribute that
        MacTerm natively handles will override the default MacTerm
        implementation.

        Your handler is given a single argument, the pathname string,
        which you must decompose yourself (but note that Python has
        built-in libraries such as the 'os.path' module to help parse).
        Generally your handler constructs a Session object with a command
        that is appropriate for the file, although you could do something
        else.

        """
        return _quills.Session_on_fileopen_call(*args, **kwargs)

    if _newclass:
        on_fileopen_call = staticmethod(on_fileopen_call)
    __swig_getmethods__["on_fileopen_call"] = lambda x: on_fileopen_call

    def on_new_call(*args):
        """
        on_new_call(inPythonFunction)

        Register a Python function to be called (with no arguments)
        every single time a session is created.

        """
        return _quills.Session_on_new_call(*args)

    if _newclass:
        on_new_call = staticmethod(on_new_call)
    __swig_getmethods__["on_new_call"] = lambda x: on_new_call

    def _on_seekpidscwds_call(*args):
        """
        _on_seekpidscwds_call(inPythonFunction)

        Register a Python function to be called (with a list argument)
        every time the current working directory of one or more processes
        is needed.  Each argument is an integer, the process ID to check.

        Return a dictionary that maps integers to strings.  Each integer
        is a process ID for which a directory could be found, and the
        corresponding string in UTF-8 encoding should be a POSIX path for
        a directory (the string may be empty if nothing was found, but it
        is also OK to simply omit process IDs that had errors).

        This function takes multiple arguments and returns a batch of
        results because it is very likely to require a fairly expensive
        lookup (currently, spawning a separate process).  Therefore, it
        is advantageous to request directories for as many processes as
        possible in a single call.

        This is currently for MacTerm internal use only.

        """
        return _quills.Session__on_seekpidscwds_call(*args)

    if _newclass:
        _on_seekpidscwds_call = staticmethod(_on_seekpidscwds_call)
    __swig_getmethods__["_on_seekpidscwds_call"] = lambda x: _on_seekpidscwds_call

    def on_urlopen_call(*args):
        """
        on_urlopen_call(inPythonFunction, schema)

        Register a Python function to be called, with a single string
        argument, every time an open is requested for a URL whose schema
        (e.g. 'http') matches the schema given as the argument to
        on_urlopen_call().  You cannot register more than one Python
        function for a particular URL schema.  Registering a Python
        function for a schema that MacTerm natively handles will
        override the default MacTerm implementation.

        Your handler is given a single argument, the URL string, which
        you must decompose yourself (but note that Python has built-in
        libraries such as the 'urlparse' module to help, and the default
        MacTerm parsers are also available in a Python module).
        Generally your handler constructs a Session object with a command
        that is appropriate for the URL, although you could do something
        else: for instance, using Python's built-in 'webbrowser' or
        'urllib' modules.

        """
        return _quills.Session_on_urlopen_call(*args)

    if _newclass:
        on_urlopen_call = staticmethod(on_urlopen_call)
    __swig_getmethods__["on_urlopen_call"] = lambda x: on_urlopen_call

    def stop_fileopen_call(*args, **kwargs):
        """
        stop_fileopen_call(inPythonFunction, extension)

        Prevent a Python function from being called when opens are
        requested for files with the given attribute.  Only one of the
        attributes (keyword parameters) should be given.  This would be
        to undo the effects of a previous call to on_fileopen_call().

        """
        return _quills.Session_stop_fileopen_call(*args, **kwargs)

    if _newclass:
        stop_fileopen_call = staticmethod(stop_fileopen_call)
    __swig_getmethods__["stop_fileopen_call"] = lambda x: stop_fileopen_call

    def stop_new_call(*args):
        """
        stop_new_call(inPythonFunction)

        Prevent a Python function from being called when sessions are
        created.  This would be to undo the effects of a previous call
        to on_new_call().

        """
        return _quills.Session_stop_new_call(*args)

    if _newclass:
        stop_new_call = staticmethod(stop_new_call)
    __swig_getmethods__["stop_new_call"] = lambda x: stop_new_call

    def stop_urlopen_call(*args):
        """
        stop_urlopen_call(inPythonFunction, schema)

        Prevent a Python function from being called when URL opens are
        requested.  This would be to undo the effects of a previous
        call to on_urlopen_call().

        """
        return _quills.Session_stop_urlopen_call(*args)

    if _newclass:
        stop_urlopen_call = staticmethod(stop_urlopen_call)
    __swig_getmethods__["stop_urlopen_call"] = lambda x: stop_urlopen_call
    __swig_destroy__ = _quills.delete_Session
    __del__ = lambda self: None
Session_swigregister = _quills.Session_swigregister
Session_swigregister(Session)

def Session_handle_file(*args):
    """
    Session_handle_file(pathname)

    Either invoke a Python callback to handle the specified file,
    or trigger the default MacTerm handler if no Python callback
    is available.  Callbacks registered via on_fileopen_call() are
    considered.

    Currently, file type is determined only using the extension of
    the pathname.

    This function returns nothing and is asynchronous; you can,
    however, use a routine like on_new_call() to be notified of
    new sessions when they appear.

    """
    return _quills.Session_handle_file(*args)

def Session_handle_url(*args):
    """
    Session_handle_url(url)

    Either invoke a Python callback to handle the specified URL,
    or trigger the default MacTerm handler if no Python callback
    is available.  Callbacks registered via on_urlopen_call() are
    considered.

    This function returns nothing and is asynchronous; you can,
    however, use a routine like on_new_call() to be notified of
    new sessions when they appear.

    """
    return _quills.Session_handle_url(*args)

def Session_keep_alive_transmission(*args):
    """
    Session_keep_alive_transmission() -> std::string

    Return what set_keep_alive_transmission() sets.

    """
    return _quills.Session_keep_alive_transmission(*args)

def Session_pids_cwds(*args):
    """
    Session_pids_cwds(pids) -> _string_by_long

    Determine the current working directories of the specified
    processes, among user-owned processes.  The result is a map by
    process ID, where nonexistent entries could not be determined
    (because a process no longer exists or you lack permission,
    etc.).  Each process ID maps to a directory path string.

    The character encoding of directory path strings is UTF-8.

    """
    return _quills.Session_pids_cwds(*args)

def Session_set_keep_alive_transmission(*args):
    """
    Session_set_keep_alive_transmission(text)

    Specify the text to send to the server when a long idle timer
    expires on a session that is watching for inactivity.

    Probably, this should be a very short string that will not
    interface with whatever happens to be running on the server; a
    single space is typical.

    """
    return _quills.Session_set_keep_alive_transmission(*args)

def Session__on_fileopen_ext_call_py(*args):
    """Session__on_fileopen_ext_call_py(arg2, arg3, arg4)"""
    return _quills.Session__on_fileopen_ext_call_py(*args)

def Session__on_new_call_py(*args):
    """Session__on_new_call_py(arg2, arg3)"""
    return _quills.Session__on_new_call_py(*args)

def Session__on_seekpidscwds_call_py(*args):
    """Session__on_seekpidscwds_call_py(arg2, arg3)"""
    return _quills.Session__on_seekpidscwds_call_py(*args)

def Session__on_urlopen_call_py(*args):
    """Session__on_urlopen_call_py(arg2, arg3, arg4)"""
    return _quills.Session__on_urlopen_call_py(*args)

def Session__stop_fileopen_ext_call_py(*args):
    """Session__stop_fileopen_ext_call_py(arg2, arg3)"""
    return _quills.Session__stop_fileopen_ext_call_py(*args)

def Session__stop_new_call_py(*args):
    """Session__stop_new_call_py(arg2)"""
    return _quills.Session__stop_new_call_py(*args)

def Session__stop_urlopen_call_py(*args):
    """Session__stop_urlopen_call_py(arg2, arg3)"""
    return _quills.Session__stop_urlopen_call_py(*args)

def Session_on_fileopen_call(*args, **kwargs):
    """
    Session_on_fileopen_call(inPythonFunction, extension)

    Register a Python function to be called, with a single string
    argument, every time an open is requested for a file with the
    given attribute.

    Specify only one attribute (keyword parameter) at a time.  You
    can reuse the same callback function, just register it more than
    once and provide a different attribute for each call.

    Currently, the only supported attribute is 'extension', which
    refers to the end of the filename without a dot (.).  Examples
    include 'txt' for text, and 'sh' for Bourne shell.  Note that the
    Finder obeys extension mappings in the 'Info.plist' file of the
    application bundle, so you may wish to update that file when
    adding new handlers.  If the 'Info.plist' does not include the
    extension you choose, your handler will only be used for files
    that are forced to open with MacTerm (say, when they are dragged
    onto the Dock icon).

    You cannot register more than one Python function for the same
    attribute.  Registering a Python function for an attribute that
    MacTerm natively handles will override the default MacTerm
    implementation.

    Your handler is given a single argument, the pathname string,
    which you must decompose yourself (but note that Python has
    built-in libraries such as the 'os.path' module to help parse).
    Generally your handler constructs a Session object with a command
    that is appropriate for the file, although you could do something
    else.

    """
    return _quills.Session_on_fileopen_call(*args, **kwargs)

def Session_on_new_call(*args):
    """
    Session_on_new_call(inPythonFunction)

    Register a Python function to be called (with no arguments)
    every single time a session is created.

    """
    return _quills.Session_on_new_call(*args)

def Session__on_seekpidscwds_call(*args):
    """
    Session__on_seekpidscwds_call(inPythonFunction)

    Register a Python function to be called (with a list argument)
    every time the current working directory of one or more processes
    is needed.  Each argument is an integer, the process ID to check.

    Return a dictionary that maps integers to strings.  Each integer
    is a process ID for which a directory could be found, and the
    corresponding string in UTF-8 encoding should be a POSIX path for
    a directory (the string may be empty if nothing was found, but it
    is also OK to simply omit process IDs that had errors).

    This function takes multiple arguments and returns a batch of
    results because it is very likely to require a fairly expensive
    lookup (currently, spawning a separate process).  Therefore, it
    is advantageous to request directories for as many processes as
    possible in a single call.

    This is currently for MacTerm internal use only.

    """
    return _quills.Session__on_seekpidscwds_call(*args)

def Session_on_urlopen_call(*args):
    """
    Session_on_urlopen_call(inPythonFunction, schema)

    Register a Python function to be called, with a single string
    argument, every time an open is requested for a URL whose schema
    (e.g. 'http') matches the schema given as the argument to
    on_urlopen_call().  You cannot register more than one Python
    function for a particular URL schema.  Registering a Python
    function for a schema that MacTerm natively handles will
    override the default MacTerm implementation.

    Your handler is given a single argument, the URL string, which
    you must decompose yourself (but note that Python has built-in
    libraries such as the 'urlparse' module to help, and the default
    MacTerm parsers are also available in a Python module).
    Generally your handler constructs a Session object with a command
    that is appropriate for the URL, although you could do something
    else: for instance, using Python's built-in 'webbrowser' or
    'urllib' modules.

    """
    return _quills.Session_on_urlopen_call(*args)

def Session_stop_fileopen_call(*args, **kwargs):
    """
    Session_stop_fileopen_call(inPythonFunction, extension)

    Prevent a Python function from being called when opens are
    requested for files with the given attribute.  Only one of the
    attributes (keyword parameters) should be given.  This would be
    to undo the effects of a previous call to on_fileopen_call().

    """
    return _quills.Session_stop_fileopen_call(*args, **kwargs)

def Session_stop_new_call(*args):
    """
    Session_stop_new_call(inPythonFunction)

    Prevent a Python function from being called when sessions are
    created.  This would be to undo the effects of a previous call
    to on_new_call().

    """
    return _quills.Session_stop_new_call(*args)

def Session_stop_urlopen_call(*args):
    """
    Session_stop_urlopen_call(inPythonFunction, schema)

    Prevent a Python function from being called when URL opens are
    requested.  This would be to undo the effects of a previous
    call to on_urlopen_call().

    """
    return _quills.Session_stop_urlopen_call(*args)

class Terminal(_object):
    """
    Customization of terminal views.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Terminal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Terminal, name)
    __repr__ = _swig_repr

    def set_dumb_string_for_char(*args):
        """
        set_dumb_string_for_char(unicode, rendering_utf8)

        Specifies an appropriate dumb-terminal rendering for the given
        character code, which is UTF-16 in the range 0-0xFFFF.  This is
        global to all terminal views that are using the DUMB emulator,
        it cannot be set on a per-screen basis.

        The dumb terminal has a default rendering for codes that have
        not specified a different rendering, and the default usually
        just prints the numerical value in angle brackets.

        """
        return _quills.Terminal_set_dumb_string_for_char(*args)

    if _newclass:
        set_dumb_string_for_char = staticmethod(set_dumb_string_for_char)
    __swig_getmethods__["set_dumb_string_for_char"] = lambda x: set_dumb_string_for_char

    def word_of_char_in_string(*args):
        """
        word_of_char_in_string(text_utf8, offset) -> _long_pair

        Return a pair of integers as a tuple, that locates a word in
        the given string.  The first integer is a character position,
        and the second integer is a character count.  Note that since
        the given string is an encoded sequence of bytes, it may well
        contain fewer characters than bytes, and offsets refer only to
        the positions of characters!  Do not use byte offsets.

        If there is no word, the pair holds the original offset in the
        first element, and the second element is 1.

        The character encoding of the given string must be UTF-8.

        Note that this calls what was registered with on_seekword_call(),
        and MacTerm installs its own routine by default.

        """
        return _quills.Terminal_word_of_char_in_string(*args)

    if _newclass:
        word_of_char_in_string = staticmethod(word_of_char_in_string)
    __swig_getmethods__["word_of_char_in_string"] = lambda x: word_of_char_in_string

    def _on_seekword_call_py(*args):
        """_on_seekword_call_py(arg1, arg2)"""
        return _quills.Terminal__on_seekword_call_py(*args)

    if _newclass:
        _on_seekword_call_py = staticmethod(_on_seekword_call_py)
    __swig_getmethods__["_on_seekword_call_py"] = lambda x: _on_seekword_call_py

    def on_seekword_call(*args):
        """
        on_seekword_call(inPythonFunction)

        Register a Python function to be called (with string and integer
        offset arguments) every time a word must be found in a string of
        text.  The string uses UTF-8 encoding, and may include new-lines.

        Return a pair of integers as a tuple, where the first is a
        zero-based CHARACTER offset into the given string, and the second
        is a CHARACTER count from that offset.  This range identifies a
        word that is found by scanning forwards and backwards from the
        given starting CHARACTER in the given string of BYTES.  Don't use
        byte offsets!  In particular, UTF-8 supports single characters
        that are described by multiple bytes, and you should be skipping
        all of the bytes to reach the next character in the string.  (It
        can be quite helpful to use the Python 'unicode' built-in object
        for this; see the default, registered in 'RunApplication.py'.)

        Typically, this is used in response to double-clicks, so the
        returned range should surround the original offset location.

        """
        return _quills.Terminal_on_seekword_call(*args)

    if _newclass:
        on_seekword_call = staticmethod(on_seekword_call)
    __swig_getmethods__["on_seekword_call"] = lambda x: on_seekword_call

    def __init__(self, *args):
        """__init__(self) -> Terminal"""
        this = _quills.new_Terminal(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _quills.delete_Terminal
    __del__ = lambda self: None
Terminal_swigregister = _quills.Terminal_swigregister
Terminal_swigregister(Terminal)

def Terminal_set_dumb_string_for_char(*args):
    """
    Terminal_set_dumb_string_for_char(unicode, rendering_utf8)

    Specifies an appropriate dumb-terminal rendering for the given
    character code, which is UTF-16 in the range 0-0xFFFF.  This is
    global to all terminal views that are using the DUMB emulator,
    it cannot be set on a per-screen basis.

    The dumb terminal has a default rendering for codes that have
    not specified a different rendering, and the default usually
    just prints the numerical value in angle brackets.

    """
    return _quills.Terminal_set_dumb_string_for_char(*args)

def Terminal_word_of_char_in_string(*args):
    """
    Terminal_word_of_char_in_string(text_utf8, offset) -> _long_pair

    Return a pair of integers as a tuple, that locates a word in
    the given string.  The first integer is a character position,
    and the second integer is a character count.  Note that since
    the given string is an encoded sequence of bytes, it may well
    contain fewer characters than bytes, and offsets refer only to
    the positions of characters!  Do not use byte offsets.

    If there is no word, the pair holds the original offset in the
    first element, and the second element is 1.

    The character encoding of the given string must be UTF-8.

    Note that this calls what was registered with on_seekword_call(),
    and MacTerm installs its own routine by default.

    """
    return _quills.Terminal_word_of_char_in_string(*args)

def Terminal__on_seekword_call_py(*args):
    """Terminal__on_seekword_call_py(arg2, arg3)"""
    return _quills.Terminal__on_seekword_call_py(*args)

def Terminal_on_seekword_call(*args):
    """
    Terminal_on_seekword_call(inPythonFunction)

    Register a Python function to be called (with string and integer
    offset arguments) every time a word must be found in a string of
    text.  The string uses UTF-8 encoding, and may include new-lines.

    Return a pair of integers as a tuple, where the first is a
    zero-based CHARACTER offset into the given string, and the second
    is a CHARACTER count from that offset.  This range identifies a
    word that is found by scanning forwards and backwards from the
    given starting CHARACTER in the given string of BYTES.  Don't use
    byte offsets!  In particular, UTF-8 supports single characters
    that are described by multiple bytes, and you should be skipping
    all of the bytes to reach the next character in the string.  (It
    can be quite helpful to use the Python 'unicode' built-in object
    for this; see the default, registered in 'RunApplication.py'.)

    Typically, this is used in response to double-clicks, so the
    returned range should surround the original offset location.

    """
    return _quills.Terminal_on_seekword_call(*args)

# This file is compatible with both classic and new-style classes.


